% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_base_subgroup_geometry.R
\name{makeRimage}
\alias{makeRimage}
\alias{makeRimage,numeric,missing-method}
\alias{makeRimage,numeric,LensPolyCoef-method}
\title{Generate a RelativeRadiusImage.}
\usage{
makeRimage(x, y)

\S4method{makeRimage}{numeric,missing}(x)

\S4method{makeRimage}{numeric,LensPolyCoef}(x, y)
}
\arguments{
\item{x}{numeric. Diameter of the circle in pixels expressed as one-length
even integer.}

\item{y}{\code{\linkS4class{LensPolyCoef}}.}
}
\value{
\code{\linkS4class{RelativeRadiusImage}}.
}
\description{
Helper function to generate a
  \code{\linkS4class{RelativeRadiusImage}}. Compute relative radius for each
  pixes needed to represent a circular hemispherical image with a \code{180}
  degrees field of view and a given diameter, expressed in pixels. For
  definition of relative radius see details of \code{\link{lensPolyCoef}}.
}
\details{
Most digital cameras take photos with an aspect ratio of 3:4, which
  means a rectangular frame. If all the circle area is in the picture frame,
  hundreds of pixels will have no-data. \code{RelativeRadiusImage} has 1:1 aspect
  ratio to minimize no-data pixels, so the circle is inscribed in a square.
  The size of the square equals the diameter of the circle. To represent the
  zenith as a point between pixels, the diameter of the circle must be even.
  In a high resolution image this restriction of snapping the zenith between
  pixels does not affect accuracy because half-pixel is less than the
  uncertainty in localizing the circle in the frame.
}
\section{Methods (by class)}{
\itemize{
\item \code{x = numeric,y = missing}: Assuming a polar projection.

\item \code{x = numeric,y = LensPolyCoef}: Used to specified a projection different from the polar.
}}

\examples{
x <- makeRimage(480)
plot(x)
x
}
\seealso{
\code{\link{makeZimage}}.
}
