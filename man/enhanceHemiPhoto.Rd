% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AAperPixelProcessingFunctions.R
\docType{methods}
\name{enhanceHemiPhoto}
\alias{enhanceHemiPhoto}
\alias{enhanceHemiPhoto,matrix-method}
\alias{enhanceHemiPhoto,CanopyPhoto-method}
\title{Enhance upward looking hemispherical photographs.}
\usage{
enhanceHemiPhoto(x, ...)

\S4method{enhanceHemiPhoto}{matrix}(x, thr = NULL, fuzziness = NULL,
  wR = 0.5, wB = 1.5, skyBlue = colorspace::sRGB(matrix(normalize(c(135,
  206, 235), 0, 255), ncol = 3)), ...)

\S4method{enhanceHemiPhoto}{CanopyPhoto}(x, mask = NULL, wR = 0.5,
  wB = 1.5, sharpen = TRUE,
  skyBlue = colorspace::sRGB(matrix(normalize(c(135, 206, 235), 0, 255), ncol
  = 3)), z = NULL, ...)
}
\arguments{
\item{x}{\code{\linkS4class{CanopyPhoto}}.}

\item{...}{Additional arguments as for \code{\link[raster]{writeRaster}}.}

\item{thr}{numeric. By default, the algorithm will try to estimate it.}

\item{fuzziness}{numeric. By default, the algorithm will try to estimate it.}

\item{wR}{numeric. Weight of red layer. See details.}

\item{wB}{numeric. Weight of blue layer. See details.}

\item{skyBlue}{\linkS4class{color}. See details.}

\item{mask}{\code{\linkS4class{BinImage}}.}

\item{sharpen}{logical. The default is TRUE, see details.}
}
\value{
numeric or \linkS4class{RasterLayer}.
}
\description{
This algorithm uses the color perceptual attributes to enhance
  the contrast between the sky and plants through fuzzy classification. Color
  has three different perceptual attributes: hue, lightness, and chroma. The
  algorithm was developed using the following premise: the color of the sky
  is different from the color of plants. It performs the next classification
  rules, here expressed in natural language: clear sky is blue and clouds
  decrease its chroma; if clouds are highly dense, then the sky is
  achromatic, and, in such cases, it can be light or dark; everything that
  does not match this description is not sky. These linguistic rules were
  translated to math language by means of fuzzy logic.
}
\details{
This is a pixelwise algorithm that evaluates if pixels are sky blue
  colored. High score means high membership to Sky Blue. When a pixel are
  achromatic, then it uses pixel brightness. The algorithm internally uses
  \code{\link{membership2color}} and \code{\link{fuzzyLightness}}. The
  argument skyBlue is the \code{targetColor} of the former function, which
  output is the argument \code{m} of the latter function. To evaluate the
  brightness of an achromatic pixel, the algorithm uses \strong{Relative
  Brightness} (see references).

  Argument \code{mask} can be used to affect the estimation of two arguments
  of \code{\link{fuzzyLightness}}. Affected arguments are \code{thr} and
  \code{fuzziness}. The function \code{\link{autoThr}} is used to estimate
  \code{thr}. To compute \code{fuzziness}, the algorithm takes the maximum
  and the minimum values of the Relative Brightness and calculate its mean.

  If sharpen is set as \code{TRUE} (default), a sharpen filter is applied to
  the raster with the membership values. This kernel is used:
  \code{matrix(c(rep(-1, 3), -1, 12, -1, rep(-1, 3)), ncol = 3)}.
}
\section{Methods (by class)}{
\itemize{
\item \code{matrix}: The output is a numeric vector.

\item \code{CanopyPhoto}: The output is a \linkS4class{RasterLayer}.
}}

\examples{
# for circular hemispherical photos
x <- loadPhoto()
x <- normalize(x, 0, 255)
xe <- enhanceHemiPhoto(x)
plot(xe)

z <- makeZimage(ncol(x), lensPolyCoef(c(0.6427, 0.0346, -0.024491)))

m <- doMask(z, zlim = asAngle(c(30,60)), alim = asAngle(c(0, 45)))
# mask affects the result but does not crop it (see Details).
plot(enhanceHemiPhoto(x, mask = m))


# for fullframe hemispherical photos

path <- system.file("external/DSC_2881.jpg", package="caiman")
x <- loadPhoto(path)
## declaring it as a fullframe
fisheye(x) <- newFishEye(TRUE, TRUE, TRUE)

x <- normalize(x, 0, 255)

lens <- lensPolyCoef(c(1.13, 0.00798, -0.138))
diameter <- calcDiameter(x, lens)
r <- makeRimage(diameter, lens)
z <- makeZimage(r, lens)

xe <- enhanceHemiPhoto(x, z = z)
plot(xe)

## Using a mask for fullframe photos is tricky (see Details).
m <- doMask(x, z)
m <- doMask(z, previousMask = m, zlim = asAngle(c(30, 40)),
                                                      alim = asAngle(c(20,130)))
plot(m)
plot(enhanceHemiPhoto(x, z = z, mask = m) - enhanceHemiPhoto(x, z = z))
}
\references{
Diaz, G.M., Lencinas, J.D., 2015. Enhanced Gap Fraction
Extraction From Hemispherical Photography. IEEE Geosci. Remote Sens. Lett.
12, 1784-1789.
}
\seealso{
\code{\link{membership2color}}, \code{\link{fuzzyLightness}}.
}
