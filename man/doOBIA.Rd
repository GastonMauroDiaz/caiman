% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/doOBIA.R
\docType{methods}
\name{doOBIA}
\alias{doOBIA}
\alias{doOBIA,CanopyPhoto-method}
\title{Do an Object-based image analysis to classify gaps.}
\usage{
doOBIA(x, bin, z, seg = doPolarQtree(x, z, scaleParameter = 0.2),
  g1 = makePolarGrid(z), sampleSize = 50, k = 1,
  zlim = asAngle(c(30, 60)), calibration = FALSE)

\S4method{doOBIA}{CanopyPhoto}(x, bin, z, seg = doPolarQtree(x, z,
  scaleParameter = 0.2), g1 = makePolarGrid(z), sampleSize = 50,
  k = 1, zlim = asAngle(c(30, 60)), calibration = FALSE)
}
\arguments{
\item{x}{\code{\linkS4class{CanopyPhoto}}.}

\item{bin}{\code{\linkS4class{BinImage}}. The standard is a call to
\code{\link{enhanceHP}} followed by a call to \code{\link{autoThr}}}

\item{z}{\code{\linkS4class{ZenithImage}}.}

\item{seg}{\code{\linkS4class{PolarSegmentation}}.}

\item{g1}{\code{\linkS4class{PolarSegmentation}}. The default option is a
PolarSegmentation created by calling \code{makePolarGrid(z)}. To save time in
batch processing of photos token with the same camera, you can compute
\code{makePolarGrid(z)} only once and provide the result through this argument.}

\item{sampleSize}{integer. Default is \code{50}, see Details.}

\item{k}{integer. Default is \code{1} nearest neighbor, see Details.}

\item{zlim}{\code{\linkS4class{Angle}}. Defaults are \code{30} to \code{60} degrees of
zenith angle, see Details.}

\item{calibration}{logical. Default is \code{FALSE}, see Details.}
}
\value{
A \code{\linkS4class{BinImage}} by default. If \code{calibrate} is
  set to \code{TRUE}, a \code{\linkS4class{RasterLayer}}.
}
\description{
Do an Object-based image analysis with the aim of classify
  gaps in full-color-upward-looking hemispherical photographs.
}
\details{
This algorithm uses object-based image analysis (OBIA). The class
  \emph{Gap-candidate} is assigned to pixels that are white in \code{bin} and
  the class \emph{Plant} to the rest of the pixels. Next, the algorithm uses
  this result and \code{g1} to isolate hemisphere segments with \code{1}
  degree of resolution that are not fully cover by \emph{Plant} (i.e., Gap
  Fraction > 0), which are classified as \emph{Mix-OR-Gap}. Next, the
  algorithm get a binary mask from this result and intersect it with the
  argument \code{seg}. At this point, the algorithms achieve the
  identification of all segments of \code{seg} that could have some gaps at
  pixel level (i.e., \emph{Mix-OR-Gap}). Next, the algorithm classified all
  this segments in \emph{Gap} or \emph{Mix} in a two stage process: (1)
  automatic selection of samples and (2) sample-based classification. The
  argument \code{sampleSize} controls the sample size for both targeted
  classes. The algorithm uses the brightness of the blue channel to select
  the samples. It assumes that brighter objects belong to \emph{Gap} and
  objects with middle brightness belong to \emph{Mix}. The argument \code{k}
  is for the knn used in the second stage of the sample-based classification.
  Processing continues on Mix-segments in order to unmix them at pixel level
  (see references for more details). The arguments \code{mnZ} and \code{mxZ}
  can be used to delimitate the range of zenith angle in which the
  aforementioned process is computed. In the rest of the image the result
  will be the same as \code{bin}.

  If calibrate is set as \code{TRUE}, the process stops just after the
  sample-based classification described in the previous paragraph and returns
  a classification at object level of \emph{Plan}, \emph{Mix} and \emph{Gap}.
  This kind of output can be used to calibrate \code{sampleSize} and
  \code{k}.
}
\examples{
x <- loadPhoto()
x <- normalize(x, 0, 255)
z <- makeZimage(ncol(x), lensPolyCoef(c(0.6427, 0.0346, -0.024491)))
m <- doMask(z)
bin <- autoThr(enhanceHP(x, m, sharpen = FALSE))


# Because next line takes too long for an example...
\dontrun{
  seg <- doPolarQtree(x, z, scaleParameter = 0.1)
}
# ... you can open the result with the following lines.
seg <- raster(system.file("external/seg.tif", package="caiman"))
seg <- as(seg, "PolarSegmentation")

g1 <- makePolarGrid(z)
zlim <- asAngle(c(20, 80))
\donttest{
out <- doOBIA(x, bin, z, seg, g1, zlim = zlim, sampleSize = 20, calibration = FALSE)
plot(out)
out <- doOBIA(x, bin, z, seg, g1, zlim = zlim, sampleSize = 20, calibration = TRUE)
plot(out)

zlim <- asAngle(c(30, 60))

out <- doOBIA(x, bin, z, seg, g1, zlim = zlim, sampleSize = 20, calibration = TRUE)
plot(out)
}


# Fullframe

path <- system.file("external/DSC_2881.jpg", package="caiman")
x <- loadPhoto(path)
### declaring it as a fullframe
fisheye(x) <- newFishEye(TRUE, TRUE, TRUE)

x <- normalize(x, 0, 255)

lens <- lensPolyCoef(c(0.71553, 0.01146, -0.03928))
angle <- asAngle(c(53))
pix <- c(224)
diameter <- calcDiameter(lens, pix, angle)
z <- makeZimage(diameter, lens)

m <- doMask(x, z)
x <- expandFullframe(x, z)

bin <- autoThr(enhanceHP(x, m, sharpen = FALSE))

\donttest{
seg <- doPolarQtree(x, z, scaleParameter = 0.2, mnSize = 1000)
out <- doOBIA(x, bin, z, seg, sampleSize = 20, calibration = TRUE)
plot(out)
out <- doOBIA(x, z, seg, sampleSize = 20, calibration = FALSE)
plot(out)
}
}
\references{
Diaz, G.M., Lencinas, J.D., 2015. Enhanced Gap Fraction
Extraction From Hemispherical Photography. IEEE Geosci. Remote Sens. Lett.
12, 1784-1789.
}
\seealso{
\code{\link{loadPhoto}}, \code{\link{doPolarQtree}}, \code{\link{makeZimage}}.
}
