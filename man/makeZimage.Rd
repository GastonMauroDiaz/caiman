% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AAgeometryFunctions.R
\docType{methods}
\name{makeZimage}
\alias{makeZimage}
\alias{makeZimage,RelativeRadiusImage,LensPolyCoef-method}
\alias{makeZimage,numeric,LensPolyCoef-method}
\title{Generate a ZenithImage.}
\usage{
makeZimage(x, y)

\S4method{makeZimage}{RelativeRadiusImage,LensPolyCoef}(x, y)

\S4method{makeZimage}{numeric,LensPolyCoef}(x, y)
}
\arguments{
\item{x}{numeric or \code{\linkS4class{RelativeRadiusImage}}.}

\item{y}{\code{linkS4class{LensPolyCoef}}.}
}
\value{
\code{\linkS4class{ZenithImage}}.
}
\description{
Helper function to generate a \code{\linkS4class{ZenithImage}}. Compute zenith angle for each pixel that is needed to represent a circular hemispherical image with 180 degrees field of view. For definition of zenith angle see details of \code{\link{lensPolyCoef}}.
}
\details{
If the \code{x} argument of a call to makeZimage is numeric, the function internally calls to makeRimage.
}
\section{Methods (by class)}{
\itemize{
\item \code{x = RelativeRadiusImage,y = LensPolyCoef}: It is the most frequent use. You only need to provide the diameter in pixels of the circle that has data in the hemispherical photographs that you want to process.

\item \code{x = numeric,y = LensPolyCoef}: In certain processing chain, maybe it could help to decrease processing time. For example, in processing same resolution photo but taken with different lens.
}}
\examples{
lens <- lensPolyCoef()
z <- makeZimage(480, lens)
plot(z)
z
}
\seealso{
\code{\linkS4class{RelativeRadiusImage}}.
}

